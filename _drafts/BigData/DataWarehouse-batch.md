# 数据仓库——离线

本文限定讨论范围为离线数据仓库。

**出现背景**

数据仓库的发展历史可以追溯到上世纪70年代。

**解决问题**

数据仓库的目的是解决"数据分析"的诉求，相比于"数据事务"即增删改查，主要解决数据的"多维查询"。

## 数仓分层

**一般分层原理**

分层的目的是"解耦"和"复用"。

**一般分层实践**

一般分为 ODS、DWD、DWS、ADS 四层，再加 DIM/维表。具体怎么分因公司而异。

**一般各层职能**

ODS 完全保留原始数据。DWD 负责自下而上模型建设，要包含全部"明细数据"，以及指向各个维度的外键值（数据清洗、维度退化、事实拉宽）。DWS 负责自上而下模型建设，至少要发生"纵向聚合"或者"横向聚合"。ADS 不需建模按需定制化加工即可。DIM 是对具体分析实体的分析角度。

## 数仓分域

**分域原则**

①按业务过程分；②按业务系统分；③按分析场景分；一般分两级即可。

**分域举例**

经营、风控、分发、Offer、授信、用信、信审、客服、催收、用户。具体比如：

```
————经营
    |————决策
    |————动作
    |————权益
    |————触达
    |————微信
    |————活动
    |————渠道
    |————小满分
    |————开放平台
    |————名单
————风控
    |————贷前
    |————贷后
    |————外部数据
————分发/机构
    |————分发决策
    |————机构额度
    |————机构价格
    |————助贷资金
    |————助贷管理
————Offer
    |————额度
    |————价格
————授信
    |————授信
    |————增信
————交易/用信
    |————交易
    |————OMG
    |————借据-核心
    |————分期-核心
    |————账户-核心
————信审
    |————信审
————客服
    |————客服
————催收
    |————催收
————用户
    |————用户行为
    |————用户设备
    |————用户组件
    |————用户ID
```

**分域实践**

ODS 一般不涉及分域。DWD 按照业务过程或者业务系统从下而上分域。DWS 按照分析场景从上而下分域。ADS 一般没必要分域。DIM 按照业务过程或者业务系统从下而上分域。

注：出于简单考虑，DWS 和 DWD（包括 DIM） 也有时候共用一套分域规则。

## 数仓时效

离线数仓一般天级 T+1 居多，小时级 H+1 也有。

## 数仓建模

### 维度建模

对比"关系/ER建模"（也叫范式建模）——指的是对 DW* 进行建模。一般可分为如下几步：

一、确定**业务过程**或业务场景——位于业务全景的哪一块——重要

二、确定**实体**或粒度或主键——明确定义事实表里的**一行代表什么**业务含义——非常重要——————\[谁\]

三、确定**维度**也就是关联维度表的维度——可能涉及维度退化——————————————————\[何时何地\]

四、确定业务**事实**信息——按需添加——————————————————————————————\[发生什么\]


### 快照表/快照事实表

**周期快照表**

周期性业务聚集事实，全量加工，_*f。

**累积快照表**

关键业务过程事实，全量加工，_*f。

### 事务表/事务事实表

完整业务变化事实，增量加工，_*d。

### 维表/维度表

配置化、属性、解释类信息，全量加工，_*f。

注：数据源有"流水表"、"状态表"的叫法，流水表是指任何变化都通过新纪录来体现的一类表，状态表也叫覆盖表，是指变化通过修改原记录体现的一类表。配置表一般指的是存放配置信息的表，配置表一般是状态表或覆盖表。记录表也叫事务表一般指的是存放交易事务记录信息的表，记录表或事务表一般是流水表。

## 模型加工

### 基本规范

理想情况，应该每一层只依赖上一层；例外也允许跨层依赖、同层依赖；严格禁止反向依赖。

ODS+DW* 所有字段均为 `string` 类型，且不允许有 `null`（应用 `coalesce()` 函数） 值，都转化成空串 `''`。

ADS 字段类型按需，一般不涉及小数字段的采用 `bigint`，涉及小数的字段采用 `decimal(38,4)` 或者 `double`。

统一时间格式，比如 `yyyy-MM-dd HH:mm:ss.SSS`。

ODS 表命名规范：`[ods]_[源表名]_[dd/df/hd/hf/md/mf]`。

DW* 模型表命名规范：`[分层]_[一级主题域]_[二级主题域]_[自定义段]_[dd/df/hd/hf/md/mf]`。

### 事务表最佳实践

#### 第一个一般性原则：MySQL【同步方式】判定策略

同步方式包括下面的同步时效、同步范围、同步字段以及同步时间点等。

注意：覆盖式数据源，**不能重新拉取**，因为当时的数据现场已被覆盖修改。

##### 同步时效 & 同步范围

![](dw-batch-dw-ingest-bp-scope.png)

**配置表**（跑批表等同于配置表）

- 覆盖：全量同步，优先 **hf**，或者权衡成本性能以及必要性降级成 df，如果降级成 df，需评估影响，另外，如果要求更高的准确性，就需要流水式的配置表或者事件产生时，原生就带有属性。
- 流水：增量同步，优先 hd，或者降级成 dd（极小概率分支，遇到具体情况可再说）。

**记录表**

- 覆盖：增量同步，优先 **hd**，或者降级成 dd。
- 流水：增量同步，优先 **hd**，或者降级成 dd。

##### 同步字段

![](dw-batch-dw-ingest-bp-fields.png)

1. 如果MySQL表是覆盖的且用到的字段是覆盖的，则同步字段是 **CREATED+MODIFED**，反例比如交易detail表同步问题。
2. 如果MySQL表是覆盖的且用到的字段是不变的，则同步字段是 **CREATED+MODIFED**，或者 **CREATED**（是否同步 MODIFED 可以取决于需求，但一般建议都同步）。

注：另外，某些情况下结合 till-now 可以取巧成只同步 MODIFIED，但不建议这么做，徒增理解成本，反例比如核心的tloan同步。

3. 如果 MySQL 表是流水，则同步字段是 **CREATED**。

注意，无论是 CREATED 还是 MODIFIED，都必须是**系统时间字段（或数据时间字段）**，而不能是带业务含义的**业务时间字段**；如果业务系统缺失系统时间字段，不得已用业务时间字段替代，需说明可行性和影响。

##### 同步时间点

![](dw-batch-dw-ingest-bp-time.png)

因为临界漂移问题，所以需要**延后同步**，反例比如授信dwd临界漂移问题。所有同步任务都应该**延后几分钟**（比如5分钟）同步。

如果数据晚到时间过晚，则属于备库延迟问题，另看。

##### 实时同步

实时同步采用DTS推送Kafka，数据量超过5G就不建议使用该链路。

#### 第二个一般性原则：DW*【加工方式】判定策略

##### 加工字段

一般来说，基于CREATED或者MODIFIED加工事件即可。

但涉及过程（比如异步回调）的事件，一般都会涉及四个字段：CREATED、BUSINESS_START、BUSINESS_END、MODIFIED。

![](dw-batch-dw-deal-bp.png)

加工策略如下：

**数据分区/dwd_hour**：目标自然时间

**读取数据时间字段**：CREATED/MODIFIED=目标分区

**事件时间/occur_time**：最**真实**的业务发生时间
- 如果事件定义为**结果**点：用 **BUSINESS_END** 作为 occur_time
- 如果事件定义为**起始**点：用 **BUSINESS_START** 作为 occur_time

注意，对于覆盖式ODS，在没有状态机的情况下，如果 MODIFIED **不只被事件发生所驱动修改**，其它DWD不关心字段也会驱动MODIFIED修改，则**必须通过某些条件能明确判断出事件发生**。

#### 第三个一般性原则：DW*加工【关联范围】判定策略

〇、先明确主表，主表的含义如下

- 0.a. 作为关联（left-join）的左表
- 0.b. 主表记录不能丢失，如果关联不上右表，属性字段置空即可，左表记录完整性要保证，例外比如权益使用dws，因为主表缺少必要业务判断属性

一、关联全表的情况

- 记录关联配置表（往往配置在前，业务事实发生在后），比如核心关联product表和method表、价格dwd关联price_code表。

二、往前关联或者对等关联的情况
- 记录表关联记录表（业务发生有先后），比如：权益使用dwd关联coupons、触达回调表关联任务下发表。具体往前关联的窗口大小，看折损率而定。

三、往后关联的情况（正常情况下不存在往后关联的情况）
- 接口流水问题，比如OMG接口流水；
- 关联记录表，主表业务发生在前，附属表业务发生在后，但注意这时候需要考虑是否主表选择错误，反例比如权益dwd变换主表case；（极小概率分支，遇到具体case，需拿出来review）
- 其它特殊处理逻辑，比如核心dwd的tx表关联tloan和op表，一般不建议如此处理。

具体往后关联的窗口大小，看折损率而定。

#### 第四个一般性原则：DW*事件【附带属性】判定策略

1. 事件只带该事件原生属性，就是在该事件上产生的属性；
2. 基本ID或公共属性（包括：did,customer_id,product_id），可以重复在所有事件上都带上，允许关联其它dwd，如果是非1:1映射关联，仅限于细找粗。
3. 事件属性枚举值全部加工(包括透传)到DW*——因此枚举值存在性可以在DW*验证——因此，模型需要设计else逻辑。

例外：

1. ADS/DWS关联补齐属性成本很高，且DWD关联补齐属性成本相对很低，且仅限于当前业务系统内关联，可以在DWD关联补齐属性，比如核心dwd放款补齐借据固有属性；
2. 业务系统本身掺杂不属于本系统的临时逻辑或者默认逻辑，出于收敛目的，可以在DWD附带加工，且允许关联其它dwd，比如权益使用dwd关联交易取助贷码。

#### 第五个一般性原则：DW*事件【加工构造】判定策略

一般来说，一个事件只能基于状态机的【唯一状态】加工。

##### 起点

1. 起点事件一般基于唯一状态加工，反例比如资金dwd的起点事件；
2. 对于覆盖式的ODS，状态机的所有非起点状态且CREATED=目标分区，都要构造一条起点事件，比如交易dwd、权益dwd（反例）、资金dwd的起点事件。
例外：
1. 多初始态，则需保留所有初始态的映射，暂无具体实例。

##### 终点

1. 终点事件一般也基于唯一状态加工；
2. 对于覆盖式的ODS，且如果MODIFIED不只被事件发生所驱动修改，则需要限定事件发生时间=目标分区来找到事件的真正发生。

例外：

1. 多终态，则需保留所有终态的映射，比如资金dwd的退票事件；
2. 另一个例外是，终态会变（出于业务系统某种不可控原因），则保留所有终态的映射，因为也没办法去重，比如触达dwd的多次回调。

总之，由于覆盖式的ODS，在每一次修改发生的时候，这条记录都会天然附带上之前的信息，所以加工事件的时候要明确能区分出来事件的真正发生时间；流水式的ODS不存在类似问题。

注：针对覆盖式ODS，我们需要构造起点事件，推荐的代码结构是先构造完整流水，再加工DWD事件，可拆分成两个独立任务。

#### 第六个一般性原则：DW*【数据合并/留存】判定策略

合并/保留总原则依赖于数据量来判定，而数据量影响的是：

1. 查询性能
2. 回溯效率（回溯效率还可以通过合并任务即动态分区提效）
3. 存储资源

分别来看。

##### 查询性能

如果查询性能受到影响，则肯定得合并，无论是增量场景还是全量场景。把高时效（多分区）的数据合并成低时效（少分区）的数据。

至于高时效的数据是否删除，则取决于存储资源占用。

##### 回溯效率

一般回溯效率可以通过合并任务即动态分区提升。如果合并任务这条路走不通，则也可以考虑合并分区，把高时效（多分区）的数据合并成低时效（少分区）的数据。

如果是回溯效率考虑，则高时效分区数据必然会删除。

##### 存储资源

**增量场景\/\*d**

目前小时级增量数据量基本都在KB或者MB级别，因此可以保留全生命周期的数据，若小时级增量数据超过5GB，则另行评估数据保留时间。

而且增量数据合并并不能减少数据存储量。

**全量场景\/\*f**

一般来说，小时级全量数据多为配置表，数据量不大且变动极低，一般数据量为KB或者MB级别的存储，此类数据可以保留全生命周期的数据。

若小时级全量占用存储接近或者超过10GB，则需要对数据进行整理，数据整理方案如下：

1. 小时级全量例行任务的数据保留最近一周的数据，对历史数据定期清理；
2. 小时级全量历史数据退化为天级全量（因为是全量数据，低时效的合并会减少数据存储量）数据存储，保留全生命周期的数据。

**回溯影响**

高时效分区合并低时效分区后，如果高时效分区数据删除，则低时效任务和高时效任务下游使用方会面临回溯问题的影响。

问题就是回溯和例行的代码不能保持一套，需要通过更底层的数据进行回溯，这就需要保证数据加工结果和例行的一致性。

另外，如果高时效分区数据不删除，则回溯（如果需要）可以通过合并任务即动态分区提效。

### ADS技术实践规范

#### 第一个一般性原则：应用层数据【加工方式】判定策略

##### 加工时效&加工范围

默认【小时级】【增量】加工，即hd。

注：鉴于eggroll这门技术的性能以及诸多限制问题，可【基于两种方案退化】：hf或者合并，具体在详设时评估，然后拿出来review。

##### 第二个一般性原则：ADS加工【关联范围】判定策略

ADS应用层数据加工，应该不涉及【关联范围】的决策，关联的问题应该在DW*层解决掉。

如果涉及关联范围，更多的也是【往后关联】，可以参照DW*层的规范。

![](dw-batch-ads-rel-scope.png)

##### 第三个一般性原则：分层判定策略

1. 是否有dws一层，通过【需求驱动】以及【是否通用】来判断，详设时明确。
2. ads/dws(如有)默认完全【基于dwd】加工，例外如push推送，需单独拿出来review。

##### 第四个一般性原则：ADS层禁止的操作

出于数据中台解耦和可维护性的考虑，一个逻辑类型只能在一个地方加工，推导出来，ADS禁止做【枚举映射】，因为【映射】天然的弱逻辑性，很容易在后续修改中被忽略或遗忘，所有枚举映射都应该在DWD层完成。码值转中文不在此禁止范围。

##### 其它技术实践规范

一般来说，无论DW*还是ADS不应该使用distinct操作符去重，默认使用distinct去重，会掩盖问题，反例比如核心dwd加工逻辑默认都加distinct、交易dwd还款事件逻辑加distinct。

一般来说，无论DW*还是ADS不应该使用union操作符达到去重的目的，应该使用union-all，否则会掩盖问题，反例比如资金dwd通过union修补另一个代码问题导致的数据重复问题。

一般来说，无论DW*还是ADS不应该使用join操作符达到去重的目的，应该使用left-join，否则会掩盖问题，反例比如标签。

例外案例，拿出来review。

禁止不加分区限制或者其它条件限制的查询全表的SQL行为。

### 快照表最佳实践


