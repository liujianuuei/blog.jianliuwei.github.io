# 面向对象设计原则

金科玉律只有一条：**高内聚低耦合（high cohesion and low coupling）**。其它的原则都是对这条的细化和解释。

### 第一条，数据应存在对象里

数据应存在对象里，这一条看似简单，但其更深层次的意义是，我们要思考数据，进行划分、归类和整理，继而为这些数据找到合适的对象表示，而这并不是一件简单的事情。

### 第二条，整个项目应该有且仅有一个实体类与对象对应

当你确定了用于承载数据的所有对象后，你就可以确定下来总共有哪些实体类与之对应，实体类与对象一一对应。整个项目应该坚持使用这些对象作为数据的载体，而不应该有其它任何保存数据的形式。除非必要，勿增实体。

### 第三条：在任何地方都必须使用实体类的全名，而非简称，包括方法名，类名，变量名等，除非这个简称人尽皆知

使用全名，而非简称，因为并不是谁都知道这个简称代表什么含义，除非，你是在给一个局部变量命名。比如 `getPerson`，这个方法名告诉我们，该方法是要返回 `Person` 对象，比如 `validatePerson`，该方法是要验证 `Person` 对象。

### 第四条，除非方法名暗示且必须这么做，才可以对传入的对象进行修改，否则禁止在其它方法里对当前对象进行修改

错误的例子：

```Java
public Person getPerson(String id) {
    Person p = ...
    p.setPreferredLanguage(Language.English);
    ...
    return p;
}
```

正确的做法是：

```Java
public Person getPerson(String id) {
    Person p = ...
    ...
    return p;
}

Person person = getPerson("10001");
person.setPreferredLanguage(Language.English);
```

这个例子显而易见，但当代码逐渐变的复杂的时候，稍不注意，就会出现在**只读**方法里修改返回对象，或者修改作为参数传入的对象的事情。我们随时要审查，是否在一个只读的方法里，进行了任何意义上的修改，哪怕是通过调用其它方法进行了间接的修改，也是不允许的。

如果你确实要在一个方法里修改对象，那么让方法名明确的指出这一点。比如 `updatePerson(Preson person)`，我们知道这个方法是要用传入的对象更新当前对象。

另外，一个很容易犯的错误就是，上面的方法声明成 `updatePerson(Language language, ...)`，把要修改的数据作为单独的变量进行传递，这是错误的，回头再看下第一条，数据应该存在对象里。

第五条：永远不要让客户端去做任何类库能够替客户端完成的事情。
第六条：任何时候集合类型都不要返回null，如果没有元素则返回空集合，即元素个数为0的集合。
第七条：使访问性最小化（在公有类中使用访问方法而非公有域），使作用域最小化，使可变性最小化（慎用可变参数，适当运用[保护性复制](ImmutableClass.md)）。
第七条：单一职责原则
第七条：里氏替换原则
第七条：依赖倒置原则：高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象；抽象不应该依赖于具体实现，具体实现应该依赖于抽象。
第七条：接口隔离原则
第七条：最少知道法则
第七条：开闭原则：对扩展开放，对修改关闭。
第七条：约定优于配置（CoC）。

http://www.uml.org.cn/mxdx/201106293.asp
